En maze runners el laberinto debe crearse dinámicamente por lo que en principio ninguna partida sera igual que otra . Para esto se utiliza un algoritmo que se ecuentra en la clase GenerarTablero.cs para crear caminos interconectados en el tablero y usando la función DFS (Depth-First Search) ,la cual verifica que todos los caminos esten conectadas y si no lo están se vuelve a generar el laberinto. Este juego por turnos opera dentro de un bucle while, que continúa mientras haya fichas activas en el juego,  donde los jugadores seleccionan sus fichas mediante el método ElegirFichas, que asigna posiciones iniciales aleatorias en el tablero. El tablero es representado como una matriz bidimensional (Casilla[,]), donde cada celda puede contener trampas, paredes, objetos o fichas distribuidas aleatoriamente en el laberinto.  Para su dibujado iterativo se utiliza la biblioteca Spectre.Console para renderizar gráficos simples en la consola ,utilizando colores y un Canvas para representar el tablero , para esto se toma un método principal DibujarTablero() que toma un arreglo bidimensional [,]que representa el tablero y una lista de Ficha como entrada ,y dibuja el tablero y las fichas en la consola . Este cuenta con un total de 5 fichas para escoger ,una por jugador, mediante el método ElegirFichas, que asigna posiciones iniciales aleatorias en el tablero, en la clase Fichas.cs se incluyen propiedades como nombre, posición en el tablero, color, habilidad especial, tiempo de reutilización(cooldown), puntos de vida e inmunidad; además implementa métodos para mover la ficha verificando si el movimiento es válido o no, interactuar con objetos, perder puntos de vida, gestionar habilidades y finalizar turnos. Al igual que cuenta con una condición de victoria entre los jugadores y es que el primero en conseguir un determinado número de objetos en el laberinto gana la partida, el juego también puede terminar cuando el personaje del jugador pierde todos sus puntos y por ende gana su contrario.
Ya hecho un análisis general del proyecto iremos a los rasgos explicados detalladamente :
* Al inicio de nuetro proyecto se encuentra la clase StartGame que utiliza la biblioteca Spectre.Console para crear una interfaz de usuario interactiva en la consola. Esta clase se encarga de mostrar la presentación del juego, las instrucciones y de gestionar las opciones del menú principal (Jugar, Instrucciones, Salir). Implementando varias funcionalidades como la presentación del juego la cual muestra un título atractivo y mensajes informativos sobre el objetivo del juego y las trampas;  el menú principal ofrececiendo opciones para iniciar el juego, ver las instrucciones o salir del juego; las instrucciones del juego proporcionando una guía básica sobre cómo jugar, incluyendo los controles y el objetivo; y salir del juego.
*La clase Ficha además de todo lo antes dicho de ella, representa a un personaje o unidad jugable dentro de un juego y define sus atributos, propiedades, habilidades y la lógica para interactuar con el entorno del juego. Contiene constructores inicializando una nueva instancia de la clase Ficha con los valores proporcionados para sus propiedades, así como múltiples métodos que permiten mover la ficha, usar su habilidad especial, perder puntos al caer en una trampa y recoger objetos para aumentar sus puntos de vida, además de las funcionalidades ya mencionadas anteriormente.
*La clase GenerarTablero define la estructura del tablero, la generación de caminos, la colocación de obstáculos, trampas y objetos. Su objetivo principal es crear tableros jugables de forma aleatoria, garantizando la conectividad entre los caminos. La estructura modular permite que cada parte del proceso sea manejada por métodos específicos, lo que facilita la comprensión y el mantenimiento del código. Cabe destacar en esta clase la función DFS (Depth-First Search) que es la encargada de verificando si todos los "caminos" del tablero están conectados entre sí, utilizando una búsqueda en profundidad para explorar el tablero y determinar la conectividad.
*TableroDrawer una calse que utiliza la biblioteca Spectre.Console para representar visualmente un tablero de juego en la consola. El objetivo principal es representar gráficamente el estado del tablero y las posiciones de las fichas seleccionadas, actualizándolo dinámicamente a medida que el juego progresa. Antes de redibujar el tablero, se limpia toda la consola con Console. Clear() para evitar superposiciones gráficas y se utiliza un objeto Canvas de la biblioteca Spectre.Console para representar gráficamente el tablero, el  tamaño del canvas se establece según las dimensiones del tablero. Después de dibujar las casillas, se recorren las fichas seleccionadas y se dibuja cada ficha sobre el canvas en su posición correspondiente, finalmente se utiliza AnsiConsole.Write(canvas) para mostrar el canvas completo en la consola.
*En la clase Program se orquesta  la ejecución del juego en consola, utilizando elementos de otras clases como StartGame, GenerarTablero, TableroDrawer, e Informacion para inicializar el juego, gestionar turnos, manejar las acciones de los jugadores y determinar cuándo termina la partida. Este contiene el método Main, que actúa como punto de entrada y coordina todo el flujo del juego. El bucle principal del juego consiste en iterar mientras haya jugadores activos, limpia y redibuja el tablero usando TableroDrawer.DibujarTablero(), actualiza y muestra la información de los jugadores y  solicita al jugador actual que elija una acción ("Mover Ficha" o "Usar Habilidad"); además de gestionar los turnos de los jugadores y contener la condición de victoria 
*La clase Trampa representa un elemento clave en la mecánica de un juego, introduciendo desafíos y penalizaciones para los jugadores. A través de una estructura clara y funciones específicas, la clase define los diferentes tipos de trampas y sus efectos sobre las fichas del juego. Se define con un constructor que requiere un tipo de trampa, utilizando un "enum" interno llamado Tipo para definir los posibles tipos de trampas: Dañominimo, Dañomaximo, y AumentarCooldown. Cuenta con exactamente 8 trampas esparcidas por el tablero aleatoriamente. El principal propósito de la clase es implementar la lógica de las trampas en el juego. El método AplicarTrampa define cómo cada tipo de trampa afecta a una ficha, mientras que ManejarTrampa se encarga de detectar cuándo una ficha entra en una casilla de trampa y aplicar el efecto correspondiente.
Instrucciones de como jugarlo:
1-Al correr el juego en la consola, el jugador 1 debera escoger su ficha y posteriormente el jugador 2 escogera entre las 4 fichas restantes, cada una con sus atributos, popiedades y habilidades únicas 
2-Las fichas puedes moverse hasta dos casillas por turno presionando en la tecla "Enter" en "Mover Ficha " , utilizando las teclas de direcciones para moverse a donde desee siempre y cuando no sea un obstáculo.
3-Solo se podra utilizar la habilidad de la ficha cuando se encuentre en su turno y el cooldown este "Listo". Para utilizar la habilidad debe presionar "Usar Habilidad" y posteriormente "Mover Ficha"(solo así el turno del jugador cambiará).
4-El juego acaba cuando una jugador consiga tres objetos amarillos, o cuando uno de los jugadores pierda todos sus puntos.
